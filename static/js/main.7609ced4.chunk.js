(this["webpackJsonpsorting-visualizer"]=this["webpackJsonpsorting-visualizer"]||[]).push([[0],{115:function(e,t,n){"use strict";n.r(t);var r=n(42),a=n.n(r),i=n(46),o=n(11),s=n(4),c=n(1),l=function(e,t,n){var r=[e[n],e[t]];e[t]=r[0],e[n]=r[1]},h=function e(t,n,r,a,i){if(n!==r){var o=Math.floor((n+r)/2);e(a,n,o,t,i),e(a,o+1,r,t,i),d(t,n,o,r,a,i)}},d=function(e,t,n,r,a,i){for(var o=t,s=t,c=n+1;s<=n&&c<=r;)a[s].barHeight,a[c].barHeight,e[o++]=a[c++];for(;s<=n;)e[o++]=a[s++];for(;c<=r;)e[o++]=a[c++]},b=function e(t,n,r,a){if(!(n>=r)){var i=Math.floor(Math.random()*(r-n)+n);n!==i&&a.push({type:"swap",indeces:[n,i]}),l(t,n,i);for(var o=t[n].barHeight,s=n,c=n+1;c<=r;)t[c].barHeight<o&&(c!==++s&&a.push({type:"swap",indeces:[c,s]}),l(t,c,s)),c++;n!==s&&a.push({type:"swap",indeces:[n,s]}),l(t,n,s),e(t,n,s-1,a),e(t,s+1,c-1,a)}},j=function(e,t){switch(t){case"bubble":return function(e){for(var t,n=[],r=Object(o.a)(e),a=r.length;a>0;a--){t=!1;for(var i=0;i<a-1;i++)r[i].barHeight>r[i+1].barHeight&&(n.push({type:"swap",indeces:[i,i+1]}),l(r,i,i+1),t=!0);if(!1===t)break}return n}(e);case"selection":return function(e){for(var t=[],n=Object(o.a)(e),r=0;r<n.length;r++){for(var a=r,i=r;i<n.length;i++)n[i].barHeight<n[a].barHeight&&(a=i);t.push({type:"swap",indeces:[r,a]}),l(n,r,a)}return t}(e);case"insertion":return function(e){for(var t=[],n=Object(o.a)(e),r=1;r<n.length;r++)for(var a=r;a>0&&n[a].barHeight<n[a-1].barHeight;)t.push({type:"swap",indeces:[a,a-1]}),l(n,a,a-1),a-=1;return t}(e);case"heap":return function(e){for(var t=[],n=Object(o.a)(e),r=1;r<n.length;r++)for(var a=n[r].barHeight,i=r;i>0;){var s=Math.floor((i-1)/2);if(a<=n[s].barHeight)break;t.push({type:"swap",indeces:[i,s]}),l(n,i,s),i=s}for(var c=n.length-1;c>0;c--){t.push({type:"swap",indeces:[0,c]}),l(n,0,c);for(var h=0,d=n[0].barHeight;;){var b=2*h+1,j=2*h+2,m=void 0,u=void 0,p=null;if(b<c&&(m=n[b].barHeight)>d&&(p=b),j<c&&((u=n[j].barHeight)>d&&null===p||u>m&&null!==p)&&(p=j),null===p)break;t.push({type:"swap",indeces:[h,p]}),l(n,h,p),h=p}}return t}(e);case"merge":return function(e){var t=[],n=Object(o.a)(e);if(n.length<=1)return n;var r=Object(o.a)(e);return h(n,0,e.length-1,r,t),t}(e);case"quick":return function(e){var t=[],n=Object(o.a)(e);return b(n,0,n.length-1,t),t}(e);default:return}},m=n(94),u=n(21),p=n(131),x=n(132),f=n(136),g=n(133),O=n(138),y=n(134),w=n(139),v=n(3),S=function(e){var t=e.sortType,n=e.onSelectSortType;return Object(v.jsxs)(w.a,{value:t,onChange:function(e){return n(e.target.value)},size:"sm",fontSize:"16px",borderRadius:"5px",children:[Object(v.jsx)("option",{value:"bubble",children:"Bubble"}),Object(v.jsx)("option",{value:"selection",children:"Selection"}),Object(v.jsx)("option",{value:"insertion",children:"Insertion"}),Object(v.jsx)("option",{value:"heap",children:"Heap"}),Object(v.jsx)("option",{value:"merge",children:"Merge"}),Object(v.jsx)("option",{value:"quick",children:"Quick"})]})},k=n(126),C=n(127),H=n(135),T=n(129),z=n(130),I=n(91),M=function(e){var t=e.isOpen,n=e.onClose,r=e.sortType,a={bubble:{title:"Bubble Sort",description:Object(v.jsxs)(v.Fragment,{children:[Object(v.jsx)(k.a,{children:"Working from the front of the array, the array elements are compared against their neighbor. In that comparison, if the larger array element is in the smaller index, the two array elements are swapped. This means that after each linear scan of the array, the largest remaining element will be in its final sorted position."}),Object(v.jsx)(k.a,{children:"Since a linear scan is done for approximately each element of the array, the algorithmic time complexity is quadratic, making Bubble Sort one of the worst performing of the comparison sorts. It has few use cases outside of teaching sorting and algorithmic complexity."})]}),code:"do\n  swapped = false\n  for i = 1 to indexOfLastUnsortedElement-1\n    if leftElement > rightElement\n      swap(leftElement, rightElement)\n      swapped = true\nwhile swapped",timeComplexity:Object(v.jsxs)(v.Fragment,{children:[Object(v.jsxs)(C.e,{children:["O(n",Object(v.jsx)("sup",{children:"2"}),")"]}),Object(v.jsx)(C.c,{children:"worst case"})]}),spaceComplexity:Object(v.jsx)(C.e,{children:"O(1)"}),badges:["stable","in-place","slow"]},selection:{title:"Selection Sort",description:Object(v.jsxs)(v.Fragment,{children:[Object(v.jsx)(k.a,{children:"Starting at index 0, selection sort will perform a linear scan of the entire array and find the smallest element amoung all elements. Then it will swap that element with the element at index 0. At that point we know that the element at index 0 is in its final sorted position. The algorithm will continue making such scans at each index until all values are in their sorted position."}),Object(v.jsx)(k.a,{children:"Similar to Bubble Sort, a linear scan is done for approximately each element of the array so the algorithmic complexity is quadratic. Selection Sort is among the worst performing of the comparison sorts. It has few use cases outside of teaching sorting and algorithmic complexity."})]}),code:"repeat (numOfElements - 1) times\n  set the first unsorted element as the minimum    \n  for each of the unsorted elements\n    if element < currentMinimum\n      set element as new minimum\n  swap minimum with first unsorted position",timeComplexity:Object(v.jsxs)(v.Fragment,{children:[Object(v.jsxs)(C.e,{children:["O(n",Object(v.jsx)("sup",{children:"2"}),")"]}),Object(v.jsx)(C.c,{children:"best/worst case"})]}),spaceComplexity:Object(v.jsx)(C.e,{children:"O(1)"}),badges:["in-place","slow"]},insertion:{title:"Insertion Sort",description:Object(v.jsxs)(v.Fragment,{children:[Object(v.jsx)(k.a,{children:"In insertion sort, we imagine that the front of the array is sorted. Starting from index 1 of the array, we make consectutive swaps with the back end of the sorted portion of the array until the element is in its relative position to the other sorted elements. This pattern continues until all elements have been sorted into their correct relative position and there are no more elements to consider."}),Object(v.jsx)(k.a,{children:"Like Bubble Sort and Selection Sort, Insertion Sort has a quadratic worst case time complexity. However, if the array is nearly sorted the algorithmic time complexity trends toward linear time. This makes Insertion Sort a potential candidate for sorting if the array is nearly sorted. A variation of Insertion Sort and Merge Sort, known as Tim Sort, is used in many languages (most notably Python) as their primary sort."})]}),code:"mark first element as sorted\nfor each unsorted element X\n  'extract' the element X\n  for j = lastSortedIndex down to 0\n    if current element j > X\n      move sorted element to the right by 1\n    break loop and insert X here",timeComplexity:Object(v.jsxs)(v.Fragment,{children:[Object(v.jsxs)(C.e,{children:["O(n",Object(v.jsx)("sup",{children:"2"}),")"]}),Object(v.jsx)(C.c,{children:"worst case"})]}),spaceComplexity:Object(v.jsx)(C.e,{children:"O(1)"}),badges:["stable","in-place","slow"]},heap:{title:"Heap Sort",description:Object(v.jsxs)(v.Fragment,{children:[Object(v.jsx)(k.a,{children:"Heap Sort uses a heap data structure to continously find the maximum value and move it to the back of the array. A heap can be built in place in an array. After building the heap, the maximum value is removed and swapped to the back element of the array. Then the heap structure is reevaluated and the process continues until each next maximum element is moved to its position in the back of the array."}),Object(v.jsx)(k.a,{children:"Building a heap from an array will take O(n) time, and each swap will take O(log(n)) for n values. Therefor, time complexity for Heap Sort will be O(n + n*log(n)) which simplifies to O(n*log(n)). Although heap sort is a fast sorting algorithm, it generally performs worse in practice than its other log-linear time complexity sorts, such as Quick Sort and Merge Sort. The underlying heap data structure, however, is widely used for maintaining priority queues or finding the smallest/largest element of a collection."})]}),code:"# construct max heap\nfor element of array\n  while elementIndex > 0\n    if parent > element\n        swap(element, parent)\n        elementIndex = parentIndex\n# sort by sequentially placing max elements\nrepeat (numOfElements - 1) times\n  swap(maxElement, lastUnsortedElement)\n  heapifyDown(0, lastUnsortedElementIndex)",timeComplexity:Object(v.jsxs)(v.Fragment,{children:[Object(v.jsx)(C.e,{children:"O(n*log(n))"}),Object(v.jsx)(C.c,{children:"best/worst case"})]}),spaceComplexity:Object(v.jsx)(C.e,{children:"O(1)"}),badges:["in-place","fast"]},merge:{title:"Merge Sort",description:Object(v.jsxs)(v.Fragment,{children:[Object(v.jsx)(k.a,{children:"Merge Sort is one of the more difficult sorts to visualize. Essentially what is happening is the array is getting split into consecutively smaller arrays, until each subarray is the length of 0 or 1. Each of the smaller arrays is then consectively merged with another array, maintaining the sorted order. Merge Sort utilizes recursion to both split and then later merge the subarrays."}),Object(v.jsx)(k.a,{children:"The best, worst, and average case time complexity of Merge Sort is O(n*log(n)), making it consistently one of the fastest comparison sorts. Since Merge Sort is also stable, it is sometimes preferred over Quick Sort if the array contains sorted objects rather than just integers (when stability matters). However, Merge Sort has a linear space complexity due to the auxiliary arrays being created on each merge, so if memory is going to be an issue than other sorts may serve better."})]}),code:"split each element into partitions of size 1\nrecursively merge adjacent partitions\n  for i = leftPartIdx to rightPartIdx\n    if leftPartHeadValue <= rightPartHeadValue      \n      copy leftPartHeadValue      \n    else: copy rightPartHeadValue      \ncopy elements back to original array",timeComplexity:Object(v.jsxs)(v.Fragment,{children:[Object(v.jsx)(C.e,{children:"O(n*log(n))"}),Object(v.jsx)(C.c,{children:"best/worst case"})]}),spaceComplexity:Object(v.jsx)(C.e,{children:"O(n)"}),badges:["stable","fast"]},quick:{title:"Quick Sort",description:Object(v.jsxs)(v.Fragment,{children:[Object(v.jsx)(k.a,{children:"Quick Sort, like Merge Sort utilizes recursion to partition an array into smaller portions. On each recursive call, a pivot is selected and then each other element is moved to the left or right of the pivot depending on its relative size. After each recursive call, the pivot that was selected will be in its final position within the array."}),Object(v.jsx)(k.a,{children:"Quick Sort can make a series of long range swaps, making it unstable. However, it generally out performs all other sorting algorithms. Quick Sort has a quadratic worst case time complexity. However, the average case time complexity of O(n*log(n)) is generally used because the worst case time complexity is nearly impossible to get on large input sizes."})]}),code:"for each (unsorted) partition\nset first element as pivot\n  storeIndex = pivotIndex + 1\n  for i = pivotIndex + 1 to rightmostIndex\n    if element[i] < element[pivot]      \n      swap(i, storeIndex); storeIndex++      \n  swap(pivot, storeIndex - 1)",timeComplexity:Object(v.jsxs)(v.Fragment,{children:[Object(v.jsx)(C.e,{children:"O(n*log(n))"}),Object(v.jsx)(C.c,{children:"average case"})]}),spaceComplexity:Object(v.jsx)(C.e,{children:"O(log(n))"}),badges:["in-place","fast"]}};return Object(v.jsxs)(H.a,{isOpen:t,onClose:n,size:"4xl",children:[Object(v.jsx)(H.g,{}),Object(v.jsxs)(H.d,{children:[Object(v.jsx)(H.f,{children:a[r].title}),Object(v.jsx)(H.c,{}),Object(v.jsxs)(H.b,{children:[Object(v.jsx)(O.a,{children:a[r].badges.map((function(e){return Object(v.jsx)(T.a,{variant:"solid",colorScheme:"slow"===e?"red":"green",children:e})}))}),Object(v.jsxs)(O.a,{children:[Object(v.jsx)(O.b,{my:"10px",children:a[r].description}),Object(v.jsxs)(O.b,{children:[Object(v.jsx)(z.a,{display:"block",whiteSpace:"pre",mb:"10px",children:a[r].code}),Object(v.jsxs)(C.b,{w:"100%",mx:"auto",textAlign:"center",children:[Object(v.jsxs)(C.a,{children:[Object(v.jsx)(C.d,{children:"Time Complexity"}),a[r].timeComplexity]}),Object(v.jsxs)(C.a,{children:[Object(v.jsx)(C.d,{children:"Space Complexity"}),a[r].spaceComplexity]})]})]})]})]}),Object(v.jsx)(H.e,{children:Object(v.jsx)(I.a,{onClick:n,children:"Close"})})]})]})},A=function(e){var t=e.onArraySizeSliderChange,n=e.onAnimationSpeedSliderChange,r=e.arraySize,a=e.animationSpeed,i=e.sortType,o=e.onSelectSortType,s=Object(p.a)(),c=s.isOpen,l=s.onOpen,h=s.onClose;return Object(v.jsxs)(x.a,{alignItems:"center",h:"10vh",w:{base:"95vw",md:"95vw",lg:"80vw"},mx:"auto",justifyContent:["space-between","space-around"],children:[Object(v.jsxs)(f.a,{"aria-label":"array size slider",min:10,max:60,step:1,defaultValue:r,focusThumbOnChange:!1,onChange:function(e){return t(e)},colorScheme:"teal",w:"25vw",children:[Object(v.jsx)(f.d,{children:Object(v.jsx)(f.b,{})}),Object(v.jsx)(f.c,{boxSize:[6,8,10],children:Object(v.jsx)(g.a,{color:"tomato",as:u.a,fontSize:{base:"16px",md:"24px",lg:"28px"}})})]}),Object(v.jsxs)(f.a,{"aria-label":"visualization speed slider",min:0,max:198,step:2,defaultValue:200-a,focusThumbOnChange:!1,onChange:function(e){return n(e)},colorScheme:"teal",w:"25vw",children:[Object(v.jsx)(f.d,{children:Object(v.jsx)(f.b,{})}),Object(v.jsx)(f.c,{boxSize:[6,8,10],children:Object(v.jsx)(g.a,{color:"tomato",as:u.j,fontSize:{base:"18px",md:"28px",lg:"30px"}})})]}),Object(v.jsxs)(O.a,{children:[Object(v.jsx)(y.a,{icon:Object(v.jsx)(u.d,{}),size:"2xs",borderRadius:"50%",border:"transparent",colorScheme:"teal",fontSize:"20px",mr:["1px","2px","5px","5px"],onClick:l}),Object(v.jsx)(M,{onClose:h,isOpen:c,sortType:i}),Object(v.jsx)(g.a,{w:["25vw","25vw","16vw","10vw"],maxWidth:"200px",children:Object(v.jsx)(S,{sortType:i,onSelectSortType:o})})]})]})},E=function(e){var t=e.arrayBars,n=e.arraySize,r=e.colorMode;return Object(v.jsx)(x.a,{h:"80vh",w:{base:"95vw",md:"95vw",lg:"80vw"},justifyContent:"space-between",mx:"auto",alignItems:"flex-end",borderBottom:"5px solid",borderColor:"light"===r?"teal.500":"teal.200",pb:"1.5vh",children:t.map((function(e){return Object(v.jsx)(g.a,{bg:"".concat(e.color,"light"===r?".500":".200"),h:"".concat(e.barHeight,"%"),w:"".concat(80/n,"%")},e.key)}))})},F=n(86),B=function(e){var t=e.stepForwardAnimation,n=e.playAnimations,r=e.pauseAnimations,a=e.stepBackwardAnimation,i=e.goToEnd,o=e.goToStart,s=e.currentAnimation,c=e.animations,l=e.isPlaying,h=e.toggleColorMode,d=e.colorMode,b=e.generateArrayBars,j=l?Object(v.jsx)(y.a,{onClick:r,icon:Object(v.jsx)(u.f,{}),colorScheme:"teal"}):Object(v.jsx)(y.a,{onClick:n,icon:Object(v.jsx)(u.g,{}),colorScheme:"teal"});return Object(v.jsxs)(x.a,{h:"10vh",w:{base:"95vw",md:"95vw",lg:"80vw"},align:"center",mx:"auto",justify:"space-between",children:[Object(v.jsx)(y.a,{onClick:b,icon:Object(v.jsx)(F.a,{}),colorScheme:"teal",fontSize:"24px",isDisabled:l}),Object(v.jsxs)(O.a,{spacing:{base:"8px",md:"20px",lg:"40px"},children:[Object(v.jsx)(y.a,{onClick:o,icon:Object(v.jsx)(u.h,{}),colorScheme:"teal"}),Object(v.jsx)(y.a,{onClick:a,icon:Object(v.jsx)(u.b,{}),colorScheme:"teal",isDisabled:l||0===s}),j,Object(v.jsx)(y.a,{onClick:t,icon:Object(v.jsx)(u.c,{}),colorScheme:"teal",isDisabled:l||s>=c.length}),Object(v.jsx)(y.a,{onClick:i,icon:Object(v.jsx)(u.i,{}),colorScheme:"teal"})]}),Object(v.jsx)(y.a,{onClick:h,icon:"light"===d?Object(v.jsx)(u.e,{}):Object(v.jsx)(u.k,{}),colorScheme:"teal",fontSize:"24px"})]})};var q=function(){var e=Object(c.useState)([]),t=Object(s.a)(e,2),n=t[0],r=t[1],a=Object(c.useState)(!1),l=Object(s.a)(a,2),h=l[0],d=l[1],b=Object(c.useState)(30),u=Object(s.a)(b,2),p=u[0],x=u[1],f=Object(c.useState)("bubble"),g=Object(s.a)(f,2),O=g[0],y=g[1],w=Object(c.useState)(50),S=Object(s.a)(w,2),k=S[0],C=S[1],H=Object(c.useRef)([]),T=Object(c.useRef)(0),z=Object(m.b)(),I=z.colorMode,M=z.toggleColorMode,F=function(){for(var e=[],t=0;t<p;t++)e.push({barHeight:Math.floor(96*Math.random())+5,color:"teal",key:t});r(e),d(!1),H.current=j(e,O),T.current=0},q=Object(c.useCallback)((function(){if(T.current>=H.current.length)d(!1);else{var e=Object(o.a)(n),t=Object(s.a)(H.current[T.current].indeces,2),a=t[0],c=t[1];switch(H.current[T.current].type){case"swap":var l=[e[c],e[a]];e[a]=l[0],e[c]=l[1];break;case"color":e=e.map((function(e,t){return t===a||t===c?Object(i.a)(Object(i.a)({},e),{},{color:"black"}):Object(i.a)(Object(i.a)({},e),{},{color:"teal"})}))}T.current++,r(e)}}),[n]);return Object(c.useEffect)((function(){F()}),[]),Object(c.useEffect)((function(){if(h){var e=setTimeout(q,k);return function(){return clearTimeout(e)}}}),[h,n,q]),Object(c.useEffect)((function(){F()}),[p,O]),Object(v.jsxs)(v.Fragment,{children:[Object(v.jsx)(A,{onArraySizeSliderChange:function(e){x(e)},onAnimationSpeedSliderChange:function(e){C(200-e)},arraySize:p,animationSpeed:k,sortType:O,onSelectSortType:function(e){y(e)}}),Object(v.jsx)(E,{arrayBars:n,arraySize:p,colorMode:I}),Object(v.jsx)(B,{stepForwardAnimation:q,playAnimations:function(){d(!0)},pauseAnimations:function(){d(!1)},stepBackwardAnimation:function(){if(!(T.current<=0)&&(T.current--,"swap"===H.current[T.current].type)){var e=Object(s.a)(H.current[T.current].indeces,2),t=e[0],a=e[1],i=Object(o.a)(n),c=[i[a],i[t]];i[t]=c[0],i[a]=c[1],r(i)}},goToEnd:function(){for(var e=Object(o.a)(n),t=T.current;t<H.current.length;t++){var a=Object(s.a)(H.current[t].indeces,2),i=a[0],c=a[1],l=[e[c],e[i]];e[i]=l[0],e[c]=l[1]}T.current=H.current.length,r(e)},goToStart:function(){for(var e=Object(o.a)(n),t=T.current-1;t>=0;t--){var a=Object(s.a)(H.current[t].indeces,2),i=a[0],c=a[1],l=[e[c],e[i]];e[i]=l[0],e[c]=l[1]}T.current=0,r(e),d(!1)},isPlaying:h,currentAnimation:T.current,animations:H.current,generateArrayBars:F,toggleColorMode:M,colorMode:I})]})},P=n(137);a.a.render(Object(v.jsx)(P.a,{children:Object(v.jsx)(q,{})}),document.getElementById("root"))}},[[115,1,2]]]);
//# sourceMappingURL=main.7609ced4.chunk.js.map